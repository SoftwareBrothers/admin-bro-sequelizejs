const {BaseProperty} = require("admin-bro");

const TYPES_MAPPING = [
    ["STRING", "string"],
    ["TEXT", "string"],
    ["INTEGER", "number"],
    ["BIGINT", "number"],
    ["FLOAT", "float"],
    ["REAL", "float"],
    ["DOUBLE", "float"],
    ["DECIMAL", "float"],
    ["DATE", "datetime"],
    ["DATEONLY", "date"],
    ["ENUM", "string"],
    ["ARRAY", "array"],
    ["JSON", "object"],
    ["JSONB", "object"],
    ["BLOB", "string"],
    ["UUID", "string"],
    ["CIDR", "string"],
    ["INET", "string"],
    ["MACADDR", "string"],
    ["RANGE", "string"],
    ["GEOMETRY", "string"],
    ["BOOLEAN", "boolean"],
];

export class Property extends BaseProperty
{
    constructor(sequelizePath)
    {
        super({path: sequelizePath.field});
        this.sequelizePath = sequelizePath;
    }

    public name()
    {
        return this.sequelizePath.field;
    }

    public isEditable()
    {
        return !this.sequelizePath._autoGenerated;
    }

    public isVisible()
    {
        // fields containing password are hidden by default
        return !this.name().match("password");
    }

    public isId()
    {
        return this.sequelizePath.primaryKey;
    }

    public reference()
    {
        return this.sequelizePath.references && this.sequelizePath.references.model;
    }

    public availableValues()
    {
        return this.sequelizePath.values && this.sequelizePath.values.length
            ? this.sequelizePath.values
            : null;
    }

    public type()
    {
        const key = TYPES_MAPPING.find(element => (
            this.sequelizePath.type.constructor.name === element[0]
        ));

        if(this.reference())
        {
            return "reference";
        }

        if(!key)
        {
            console.warn(`Unhandled type: ${this.sequelizePath.type}`);
        }
        const type = key && key[1];
        return type || "string";
    }
}
